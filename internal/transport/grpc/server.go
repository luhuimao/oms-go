package grpc

import (
	"context"

	omsv1 "oms-contract/api/proto"
	"oms-contract/internal/domain"
	"oms-contract/internal/service"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Server implements the OMS gRPC service
type Server struct {
	omsv1.UnimplementedOMSServer
	orderService    *service.OrderService
	positionService *service.PositionService
}

// NewServer creates a new gRPC server instance
func NewServer(os *service.OrderService, ps *service.PositionService) *Server {
	return &Server{
		orderService:    os,
		positionService: ps,
	}
}

// CreateOrder handles order creation requests
func (s *Server) CreateOrder(ctx context.Context, req *omsv1.CreateOrderRequest) (*omsv1.CreateOrderResponse, error) {
	if req.UserId <= 0 {
		return nil, status.Error(codes.InvalidArgument, "invalid user_id")
	}
	if req.Symbol == "" {
		return nil, status.Error(codes.InvalidArgument, "invalid symbol")
	}
	if req.Quantity <= 0 {
		return nil, status.Error(codes.InvalidArgument, "invalid quantity")
	}

	order := &domain.Order{
		UserID:   req.UserId,
		Symbol:   req.Symbol,
		Side:     mapSide(req.Side),
		Type:     mapOrderType(req.Type),
		Price:    req.Price,
		Quantity: req.Quantity,
		// ID will be generated by the service/idgen
	}

	// ID is generated and returned by CreateOrder
	orderID := s.orderService.CreateOrder(order)

	return &omsv1.CreateOrderResponse{
		OrderId: orderID,
		Status:  omsv1.OrderStatus_ORDER_STATUS_SUBMITTED,
	}, nil
}

// GetOrder retrieves an order (Not implemented in service yet, but let's add placeholder)
func (s *Server) GetOrder(ctx context.Context, req *omsv1.GetOrderRequest) (*omsv1.GetOrderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOrder not implemented")
}

// CancelOrder handles cancel requests
func (s *Server) CancelOrder(ctx context.Context, req *omsv1.CancelOrderRequest) (*omsv1.CancelOrderResponse, error) {
	// Not implemented in service yet
	return nil, status.Error(codes.Unimplemented, "method CancelOrder not implemented")
}

// GetPosition retrieves a position
func (s *Server) GetPosition(ctx context.Context, req *omsv1.GetPositionRequest) (*omsv1.GetPositionResponse, error) {
	position, ok := s.positionService.Get(req.UserId, req.Symbol)
	if !ok {
		return nil, status.Error(codes.NotFound, "position not found")
	}

	return &omsv1.GetPositionResponse{
		UserId:        position.UserID,
		Symbol:        position.Symbol,
		Quantity:      position.Qty,
		EntryPrice:    position.EntryPrice,
		Margin:        position.Margin,
		Leverage:      position.Leverage,
		UnrealizedPnl: position.UnrealizedPnL,
	}, nil
}

// Map helpers
func mapSide(s omsv1.Side) domain.Side {
	switch s {
	case omsv1.Side_SIDE_BUY:
		return domain.Buy
	case omsv1.Side_SIDE_SELL:
		return domain.Sell
	}
	// Default to Buy if unspecified, or handle error.
	return domain.Buy
}

func mapOrderType(t omsv1.OrderType) domain.OrderType {
	switch t {
	case omsv1.OrderType_ORDER_TYPE_LIMIT:
		return domain.Limit
	case omsv1.OrderType_ORDER_TYPE_MARKET:
		return domain.Market
	}
	return domain.Limit
}
